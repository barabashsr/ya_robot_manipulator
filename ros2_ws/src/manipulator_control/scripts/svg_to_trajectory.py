#!/usr/bin/env python3
"""Convert SVG Bezier paths to ROS2 trajectory YAML using external config.

This script is a development tool that converts visually-designed SVG paths
into waypoint YAML files for robot trajectory execution.

Workflow:
1. Design curves in Inkscape (unitless SVG)
2. Define scaling in trajectory_config.yaml
3. Run this converter to generate waypoints
4. Commit generated YAML to repository

Usage:
    python3 svg_to_trajectory.py --config config/trajectory_config.yaml \
        --trajectory extract_left -o config/extraction_trajectories.yaml
"""
import argparse
from datetime import datetime
from pathlib import Path

import numpy as np
import yaml
from svgpathtools import svg2paths


def svg_to_waypoints(svg_file: str, mapping: dict, sampling: dict) -> dict:
    """Convert SVG paths to waypoints using scaling from config.

    Args:
        svg_file: Path to SVG file
        mapping: Dict with x_range, y_output, y_center, z_scale
        sampling: Dict with num_points

    Returns:
        Dict mapping path IDs to list of {y, z} waypoints
    """
    paths, attributes = svg2paths(svg_file)

    x_min, x_max = mapping['x_range']
    y_min, y_max = mapping['y_output']
    y_center = mapping['y_center']
    z_scale = mapping['z_scale']
    num_points = sampling['num_points']

    trajectories = {}
    for path, attr in zip(paths, attributes):
        path_id = attr.get('id', f'path_{len(trajectories)}')
        waypoints = []

        for t in np.linspace(0, 1, num_points):
            point = path.point(t)
            # Scale SVG X to joint Y using config
            y = (point.real - x_min) / (x_max - x_min) * (y_max - y_min) + y_min
            # Scale SVG Y deviation from center to joint Z offset
            z = (y_center - point.imag) * z_scale
            waypoints.append({
                'y': round(float(y), 4),
                'z': round(float(z), 4)
            })

        trajectories[path_id] = waypoints

    return trajectories


def main():
    parser = argparse.ArgumentParser(
        description='Convert SVG Bezier paths to trajectory YAML'
    )
    parser.add_argument(
        '--config',
        required=True,
        help='Path to trajectory_config.yaml'
    )
    parser.add_argument(
        '--trajectory',
        required=True,
        help='Trajectory name from config (e.g., extract_left)'
    )
    parser.add_argument(
        '-o', '--output',
        required=True,
        help='Output YAML file path'
    )
    args = parser.parse_args()

    # Load config
    config_path = Path(args.config)
    with open(config_path) as f:
        config = yaml.safe_load(f)

    if 'trajectories' not in config:
        raise ValueError(f"Config missing 'trajectories' key: {args.config}")

    if args.trajectory not in config['trajectories']:
        available = list(config['trajectories'].keys())
        raise ValueError(
            f"Unknown trajectory '{args.trajectory}'. Available: {available}"
        )

    traj_config = config['trajectories'][args.trajectory]

    # Resolve SVG path relative to config file
    svg_file = config_path.parent / traj_config['svg_file']
    if not svg_file.exists():
        raise FileNotFoundError(f"SVG file not found: {svg_file}")

    # Convert SVG to waypoints
    trajectories = svg_to_waypoints(
        str(svg_file),
        traj_config['mapping'],
        traj_config['sampling']
    )

    # Build output structure (AC3)
    output = {
        'source_svg': traj_config['svg_file'],
        'config_used': str(args.config),
        'generated': datetime.now().isoformat(),
        'trajectories': trajectories
    }

    # Write output
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, 'w') as f:
        # Add header comment
        f.write("# Generated by svg_to_trajectory.py - DO NOT EDIT MANUALLY\n")
        f.write(f"# Regenerate with: python3 {' '.join(['scripts/svg_to_trajectory.py', '--config', args.config, '--trajectory', args.trajectory, '-o', args.output])}\n")
        yaml.dump(output, f, default_flow_style=False, sort_keys=False)

    print(f"Generated {output_path} with {len(trajectories)} trajectories")
    for name, wps in trajectories.items():
        print(f"  {name}: {len(wps)} waypoints")
        if wps:
            print(f"    first: y={wps[0]['y']:.4f}, z={wps[0]['z']:.4f}")
            print(f"    last:  y={wps[-1]['y']:.4f}, z={wps[-1]['z']:.4f}")


if __name__ == '__main__':
    main()
