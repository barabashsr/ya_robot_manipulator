<story-context id="2-2-create-controller-interface-utility" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2</storyId>
    <title>Create Controller Interface Utility</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-25</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-2-create-controller-interface-utility.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>a utility to send position commands to individual ForwardCommandController instances</iWant>
    <soThat>action servers can control joints without hardcoding controller topic names</soThat>
    <tasks>
      <task id="1" ac="1,2,3,4,5,6,7,8">Implement ControllerInterface Class
        <subtask id="1.1">Create src/controller_interface.py</subtask>
        <subtask id="1.2">Implement __init__() - load limits from manipulator_params.yaml, create publishers, subscribe to joint_states</subtask>
        <subtask id="1.3">Implement _load_joint_limits_from_params() - parse manipulator_params.yaml structure for soft limits</subtask>
        <subtask id="1.4">Implement _joint_state_cb() - update position cache from /joint_states</subtask>
        <subtask id="1.5">Implement command_joint() - validate position against soft limits, publish Float64</subtask>
        <subtask id="1.6">Implement command_joint_group() - iterate and command multiple joints</subtask>
        <subtask id="1.7">Implement get_joint_position() - return from position cache</subtask>
        <subtask id="1.8">Implement get_joint_limits() - return (min, max) tuple</subtask>
        <subtask id="1.9">Add logging for all validation failures</subtask>
      </task>
      <task id="2" ac="9,10">Create Test Scripts
        <subtask id="2.1">Create test/test_controller_interface.py with pytest unit tests</subtask>
        <subtask id="2.2">Create scripts/test_controller_interface_manual.py for Gazebo testing</subtask>
        <subtask id="2.3">Add comprehensive test commands to story documentation</subtask>
      </task>
      <task id="3" ac="1">Update Package Configuration
        <subtask id="3.1">Update CMakeLists.txt to install controller_interface.py to lib/</subtask>
        <subtask id="3.2">Rebuild package and verify installation</subtask>
      </task>
      <task id="4" ac="all">Developer Self-Validation (MANDATORY)
        <subtask id="4.1">Run unit tests with pytest</subtask>
        <subtask id="4.2">Run manual Gazebo test with documented commands</subtask>
        <subtask id="4.3">Verify all 9 joints respond to commands</subtask>
        <subtask id="4.4">Verify limit validation rejects out-of-range commands</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <ac id="1">ControllerInterface class exists at ros2_ws/src/manipulator_control/src/controller_interface.py</ac>
    <ac id="2">Utility discovers and maps all 9 joint controllers from manipulator_controllers.yaml</ac>
    <ac id="3">command_joint(joint_name, position) publishes Float64 to correct controller topic</ac>
    <ac id="4">command_joint_group(joint_names, positions) commands multiple joints simultaneously</ac>
    <ac id="5">get_joint_position(joint_name) returns current position from /joint_states</ac>
    <ac id="6">Position commands are validated against joint soft limits before publishing</ac>
    <ac id="7">Invalid commands return False with logged warning (not exception)</ac>
    <ac id="8">Joint soft limits loaded from manipulator_params.yaml at runtime</ac>
    <ac id="9">Unit tests exist at test/test_controller_interface.py</ac>
    <ac id="10">Manual test script demonstrates all methods working in Gazebo</ac>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-2.md</path>
        <title>Epic 2 Technical Specification</title>
        <section>Controller Interface Utility</section>
        <snippet>ControllerInterface utility class for commanding ForwardCommandControllers. NOT a ROS2 node - requires parent node reference. Validates against soft limits from manipulator_params.yaml.</snippet>
      </doc>
      <doc>
        <path>docs/architecture-ros2-control-v2-CORRECTIONS.md</path>
        <title>ROS2 Control Architecture v2.1</title>
        <section>Section 9 - Configuration Management (Single Source of Truth)</section>
        <snippet>Unified Limits Architecture: manipulator_params.yaml is PRIMARY SOURCE. Soft limits = Controller limits. ControllerInterface loads from same YAML file.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epics</title>
        <section>Story 2.2</section>
        <snippet>Create ControllerInterface utility. USE: manipulator_params.yaml for joint limits. DO NOT CREATE: New config files. DO NOT DUPLICATE: Controller limits inside Python code.</snippet>
      </doc>
    </docs>
    <code>
      <file>
        <path>ros2_ws/src/manipulator_control/CMakeLists.txt</path>
        <kind>build-config</kind>
        <symbol>CMakeLists.txt</symbol>
        <reason>Must update to install controller_interface.py to lib/ directory</reason>
      </file>
      <file>
        <path>ros2_ws/src/manipulator_control/src/virtual_limit_switches.py</path>
        <kind>reference</kind>
        <symbol>VirtualLimitSwitchNode</symbol>
        <reason>Reference implementation pattern from Story 2.1 - node structure, YAML loading</reason>
      </file>
      <file>
        <path>ros2_ws/src/manipulator_description/config/manipulator_params.yaml</path>
        <kind>config</kind>
        <symbol>manipulator_params.yaml</symbol>
        <reason>SINGLE SOURCE OF TRUTH - load soft limits from safety_controller sections</reason>
      </file>
      <file>
        <path>ros2_ws/src/manipulator_description/config/manipulator_controllers.yaml</path>
        <kind>config</kind>
        <symbol>manipulator_controllers.yaml</symbol>
        <reason>Reference for controller names (topic pattern: /{joint_name}_controller/command)</reason>
      </file>
      <file>
        <path>ros2_ws/src/manipulator_description/urdf/manipulator/ros2_control.xacro</path>
        <kind>urdf</kind>
        <symbol>ros2_control.xacro</symbol>
        <reason>Reference - shows how ros2_control loads limits from manipulator_params.yaml</reason>
      </file>
    </code>
    <dependencies>
      <ros2>
        <pkg>rclpy</pkg>
        <pkg>std_msgs</pkg>
        <pkg>sensor_msgs</pkg>
        <pkg>ament_index_python</pkg>
      </ros2>
      <python>
        <pkg>yaml</pkg>
        <pkg>typing</pkg>
      </python>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="architecture">ControllerInterface is a UTILITY CLASS, not a ROS2 node - requires parent node reference</constraint>
    <constraint type="config">NO new config files - load limits from existing manipulator_params.yaml</constraint>
    <constraint type="config">NO duplication of limit values - parse from YAML at runtime</constraint>
    <constraint type="limits">Validate against SOFT LIMITS (safety_controller), not hard limits</constraint>
    <constraint type="message">Use std_msgs/Float64 for position commands (not Float64MultiArray)</constraint>
    <constraint type="topic">Controller topic pattern: /{joint_name}_controller/command</constraint>
    <constraint type="compatibility">ROS2 Jazzy + Gazebo Harmonic</constraint>
  </constraints>

  <interfaces>
    <!-- Publishers to controller command topics -->
    <topic name="/base_main_frame_joint_controller/command" type="std_msgs/Float64" direction="publish"/>
    <topic name="/main_frame_selector_frame_joint_controller/command" type="std_msgs/Float64" direction="publish"/>
    <topic name="/selector_frame_gripper_joint_controller/command" type="std_msgs/Float64" direction="publish"/>
    <topic name="/selector_frame_picker_frame_joint_controller/command" type="std_msgs/Float64" direction="publish"/>
    <topic name="/picker_frame_picker_rail_joint_controller/command" type="std_msgs/Float64" direction="publish"/>
    <topic name="/picker_rail_picker_base_joint_controller/command" type="std_msgs/Float64" direction="publish"/>
    <topic name="/picker_base_picker_jaw_joint_controller/command" type="std_msgs/Float64" direction="publish"/>
    <topic name="/selector_left_container_jaw_joint_controller/command" type="std_msgs/Float64" direction="publish"/>
    <topic name="/selector_right_container_jaw_joint_controller/command" type="std_msgs/Float64" direction="publish"/>
    <!-- Subscription to joint states -->
    <subscription name="/joint_states" type="sensor_msgs/JointState"/>
  </interfaces>

  <tests>
    <standards>Build verification + unit tests + Gazebo integration. Verify all 9 joints respond, limits enforced, position feedback works.</standards>
    <locations>
      <location>ros2_ws/src/manipulator_control/src/controller_interface.py</location>
      <location>ros2_ws/src/manipulator_control/test/test_controller_interface.py</location>
      <location>ros2_ws/src/manipulator_control/scripts/test_controller_interface_manual.py</location>
    </locations>
    <ideas>
      <idea ac="3">command_joint('base_main_frame_joint', 1.0) publishes to /base_main_frame_joint_controller/command</idea>
      <idea ac="6">command_joint('base_main_frame_joint', 10.0) returns False (outside soft limit 3.9)</idea>
      <idea ac="7">command_joint('fake_joint', 1.0) returns False with warning logged</idea>
      <idea ac="5">get_joint_position('base_main_frame_joint') returns current position after joint_states callback</idea>
      <idea ac="4">command_joint_group(['base_main_frame_joint', 'main_frame_selector_frame_joint'], [2.0, 0.5]) commands both</idea>
      <idea ac="8">Limits match manipulator_params.yaml safety_controller values exactly</idea>
    </ideas>
  </tests>

  <previousStoryLearnings>
    <epic key="story-2.1" status="done">
      <summary>Virtual Limit Switches implemented. 18 topics publishing at /manipulator/end_switches/*. Unified launch file available.</summary>
      <newFiles>
        <file>ros2_ws/src/manipulator_control/src/virtual_limit_switches.py</file>
        <file>ros2_ws/src/manipulator_control/config/limit_switches.yaml</file>
        <file>ros2_ws/src/manipulator_control/launch/virtual_limit_switches.launch.py</file>
        <file>ros2_ws/src/manipulator_control/launch/manipulator_simulation.launch.py</file>
      </newFiles>
      <architecturalDecisions>
        <decision>CMakeLists.txt installs Python to lib/${PROJECT_NAME} with RENAME</decision>
        <decision>Config files installed to share/${PROJECT_NAME}/config</decision>
        <decision>Launch files installed to share/${PROJECT_NAME}/launch</decision>
        <decision>Build time: ~0.7s for rebuild, ~2.5s clean build</decision>
      </architecturalDecisions>
      <learnings>
        <learning>Trigger positions need ~5mm inset from URDF limits due to Gazebo boundary bouncing</learning>
        <learning>Use ament_index_python.packages.get_package_share_directory() for config file paths</learning>
      </learnings>
    </epic>
  </previousStoryLearnings>

  <jointLimitsReference>
    <note>SOFT LIMITS from manipulator_params.yaml safety_controller - these are validation limits for ControllerInterface</note>
    <joint name="base_main_frame_joint" soft_lower="0.1" soft_upper="3.9" hard_lower="0.0" hard_upper="4.0" axis="X"/>
    <joint name="main_frame_selector_frame_joint" soft_lower="0.05" soft_upper="1.45" hard_lower="-0.01" hard_upper="1.5" axis="Z"/>
    <joint name="selector_frame_gripper_joint" soft_lower="-0.39" soft_upper="0.39" hard_lower="-0.4" hard_upper="0.4" axis="Y"/>
    <joint name="selector_frame_picker_frame_joint" soft_lower="0.005" soft_upper="0.29" hard_lower="-0.01" hard_upper="0.3" axis="Z"/>
    <joint name="picker_frame_picker_rail_joint" soft_lower="-0.29" soft_upper="0.29" hard_lower="-0.3" hard_upper="0.3" axis="Y"/>
    <joint name="picker_rail_picker_base_joint" soft_lower="0.005" soft_upper="0.24" hard_lower="0.0" hard_upper="0.25" axis="X"/>
    <joint name="picker_base_picker_jaw_joint" soft_lower="0.005" soft_upper="0.19" hard_lower="0.0" hard_upper="0.2" axis="X"/>
    <joint name="selector_left_container_jaw_joint" soft_lower="-0.19" soft_upper="0.19" hard_lower="-0.2" hard_upper="0.2" axis="-Y"/>
    <joint name="selector_right_container_jaw_joint" soft_lower="-0.19" soft_upper="0.19" hard_lower="-0.2" hard_upper="0.2" axis="+Y"/>
  </jointLimitsReference>

  <configurationReusePolicy>
    <use>
      <item>manipulator_description/config/manipulator_params.yaml - PRIMARY SOURCE for joint limits (soft + hard)</item>
      <item>manipulator_description/config/manipulator_controllers.yaml - controller names reference</item>
    </use>
    <doNotCreate>
      <item>NO new YAML config files for limits</item>
      <item>NO duplication of limit values anywhere</item>
    </doNotCreate>
    <doNotDuplicate>
      <item>Controller limits inside Python code - load from YAML</item>
      <item>Controller topic names - derive from joint names using pattern: /{joint_name}_controller/command</item>
    </doNotDuplicate>
  </configurationReusePolicy>

  <codeSnippets>
    <snippet name="load_joint_limits_from_params" language="python">
<![CDATA[
def _load_joint_limits_from_params(self) -> dict:
    """Load soft limits from manipulator_params.yaml (single source of truth)."""
    from ament_index_python.packages import get_package_share_directory
    import yaml
    import os

    pkg_path = get_package_share_directory('manipulator_description')
    params_file = os.path.join(pkg_path, 'config', 'manipulator_params.yaml')

    with open(params_file, 'r') as f:
        params = yaml.safe_load(f)

    limits = {}
    # Search through all assemblies for joint definitions
    for assembly_name, assembly in params.items():
        if not isinstance(assembly, dict):
            continue
        for key, value in assembly.items():
            # Joint entries have 'safety_controller' with soft limits
            if isinstance(value, dict) and 'safety_controller' in value:
                joint_name = key
                sc = value['safety_controller']
                limits[joint_name] = {
                    'min': sc['soft_lower'],
                    'max': sc['soft_upper'],
                    'velocity': value['limits'].get('velocity', 1.0),
                }
    return limits
]]>
    </snippet>
    <snippet name="command_joint" language="python">
<![CDATA[
def command_joint(self, joint_name: str, position: float) -> bool:
    """Command single joint to position. Returns False if validation fails."""
    if joint_name not in self.joint_limits:
        self.logger.warning(f"Unknown joint: {joint_name}")
        return False

    limits = self.joint_limits[joint_name]
    if not (limits['min'] <= position <= limits['max']):
        self.logger.warning(
            f"Position {position} outside soft limits [{limits['min']}, {limits['max']}] for {joint_name}"
        )
        return False

    msg = Float64()
    msg.data = position
    self.publishers[joint_name].publish(msg)
    return True
]]>
    </snippet>
  </codeSnippets>
</story-context>
