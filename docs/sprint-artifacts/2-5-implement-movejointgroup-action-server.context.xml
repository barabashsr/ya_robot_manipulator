<story-context id="2-5-movejointgroup-action-server" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>5</storyId>
    <title>Implement MoveJointGroup Action Server</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-26</generatedAt>
    <generator>BMAD Story Context Workflow (SM Agent)</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-5-implement-movejointgroup-action-server.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>to command groups of joints simultaneously (navigation, gripper, picker, container)</iWant>
    <soThat>I can execute coordinated multi-joint motions efficiently</soThat>
    <tasks>
      <task id="1">Create kinematic_chains.yaml configuration file with joint group definitions</task>
      <task id="2">Implement MoveJointGroupServer node with ControllerInterface</task>
      <task id="3">Implement execute_callback with simultaneous motion and aggregate progress</task>
      <task id="4">Implement container jaw mimic mode (single value -> symmetric positions)</task>
      <task id="5">Implement coordinated arrival check (1-second window)</task>
      <task id="6">Update launch file and CMakeLists.txt</task>
      <task id="7">Manual testing - DEVELOPER MUST VERIFY COORDINATED MOTION</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">MoveJointGroup action server running at /move_joint_group</criterion>
    <criterion id="AC2">Loads predefined joint group definitions from config/kinematic_chains.yaml</criterion>
    <criterion id="AC3">Validates target_positions array length matches joint count and all positions within soft limits</criterion>
    <criterion id="AC4">Commands all joints simultaneously using ControllerInterface</criterion>
    <criterion id="AC5">Monitors all joints and computes aggregate progress (average of individual progress)</criterion>
    <criterion id="AC6">Returns success when ALL joints reach targets within 0.01m tolerance or timeout (30s)</criterion>
    <criterion id="AC7">Publishes feedback at 10 Hz with current_positions[] and progress_percent</criterion>
    <criterion id="AC8">Supports named groups: navigation, gripper, picker, container</criterion>
    <criterion id="AC9">Container group implements software mimic (left = -opening/2, right = +opening/2)</criterion>
    <criterion id="AC10">All joints must reach targets within 1 second of each other (coordinated arrival)</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Story 2.5: Implement MoveJointGroup Action Server</section>
        <snippet>As a developer, I want to command groups of joints simultaneously. Reference architecture lines 2386-2423 for joint group definitions. Container group implements software mimic.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-2.md</path>
        <title>Epic 2 Technical Specification</title>
        <section>config/kinematic_chains.yaml</section>
        <snippet>Joint groups: navigation (X-Z positioning), gripper (Y-axis with Z adjustment), picker (4 joints), container (synchronized mimic). Default velocities and descriptions per group.</snippet>
      </doc>
    </docs>

    <code>
      <file>
        <path>ros2_ws/src/manipulator_control/src/move_joint_server.py</path>
        <kind>reference-implementation</kind>
        <symbol>MoveJointServer</symbol>
        <reason>PATTERN REFERENCE: Follow this exact structure for MoveJointGroupServer. Same config loading, goal_callback validation, execute_callback loop, progress calculation, timeout handling.</reason>
      </file>
      <file>
        <path>ros2_ws/src/manipulator_control/src/controller_interface.py</path>
        <kind>utility-class</kind>
        <symbol>ControllerInterface</symbol>
        <reason>REUSE: Use command_joint_group() for simultaneous commands. Use get_joint_position() for feedback. Use get_joint_limits() for validation. Already handles trajectory vs forward command routing.</reason>
      </file>
      <file>
        <path>ros2_ws/src/manipulator_control/action/MoveJointGroup.action</path>
        <kind>action-interface</kind>
        <reason>ACTION DEFINITION: Goal has joint_names[], target_positions[], max_velocity. Feedback has current_positions[], progress_percent. Result has success, final_positions[], position_error, execution_time, message.</reason>
      </file>
      <file>
        <path>ros2_ws/src/manipulator_control/config/action_servers.yaml</path>
        <kind>config-source</kind>
        <reason>LOAD: move_joint_group section has timeout_sec=30.0, position_tolerance=0.01, feedback_rate=10.0. Already exists - DO NOT duplicate.</reason>
      </file>
      <file>
        <path>ros2_ws/src/manipulator_control/launch/manipulator_simulation.launch.py</path>
        <kind>launch-file</kind>
        <reason>MODIFY: Add move_joint_group_server node with 3s TimerAction delay. Follow existing pattern for move_joint_server_node.</reason>
      </file>
      <file>
        <path>ros2_ws/src/manipulator_control/CMakeLists.txt</path>
        <kind>build-config</kind>
        <reason>MODIFY: Add install rule for move_joint_group_server.py. Add kinematic_chains.yaml to config directory install.</reason>
      </file>
      <file>
        <path>ros2_ws/src/manipulator_description/config/manipulator_params.yaml</path>
        <kind>config-reference</kind>
        <reason>REFERENCE: Joint soft limits defined here. ControllerInterface loads these automatically - DO NOT duplicate in kinematic_chains.yaml.</reason>
      </file>
    </code>

    <dependencies>
      <ros2>
        <package>rclpy</package>
        <package>rclpy.action</package>
        <package>sensor_msgs</package>
        <package>control_msgs</package>
        <package>trajectory_msgs</package>
      </ros2>
      <internal>
        <package>manipulator_control</package>
        <module>controller_interface.py</module>
      </internal>
    </dependencies>
  </artifacts>

  <interfaces>
    <interface>
      <name>MoveJointGroup Action</name>
      <kind>ROS2 Action</kind>
      <signature>
        ACTION: /move_joint_group (manipulator_control/action/MoveJointGroup)

        GOAL:
          string[] joint_names        # Joint names OR empty if using named group
          float64[] target_positions  # Target positions (length must match joints)
          float64 max_velocity        # Max velocity (0.0 = use default)

        FEEDBACK (10 Hz):
          float64[] current_positions # Current positions of all joints
          float64 progress_percent    # Aggregate completion (0-100)

        RESULT:
          bool success
          float64[] final_positions
          float64 position_error      # Max error across all joints
          float64 execution_time
          string message
      </signature>
    </interface>
    <interface>
      <name>kinematic_chains.yaml Structure</name>
      <kind>Configuration File</kind>
      <signature>
        joint_groups:
          navigation:
            joints: [base_main_frame_joint, main_frame_selector_frame_joint]
            description: "X-Z positioning for address navigation"
            default_velocity: 0.5

          gripper:
            joints: [selector_frame_gripper_joint, main_frame_selector_frame_joint]
            description: "Gripper Y-axis with Z adjustment"
            default_velocity: 0.3

          picker:
            joints:
              - selector_frame_picker_frame_joint
              - picker_frame_picker_rail_joint
              - picker_rail_picker_base_joint
              - picker_base_picker_jaw_joint
            description: "All picker joints for item picking"
            default_velocity: 0.2

          container:
            joints:
              - selector_left_container_jaw_joint
              - selector_right_container_jaw_joint
            description: "Container jaws (synchronized mimic)"
            default_velocity: 0.1
            mimic_mode: true  # Single opening value -> symmetric positions
      </signature>
    </interface>
    <interface>
      <name>ControllerInterface API (existing)</name>
      <kind>Python Utility Class</kind>
      <signature>
        class ControllerInterface:
            def command_joint_group(joint_names: List[str], positions: List[float]) -> bool
            def get_joint_position(joint_name: str) -> Optional[float]
            def get_joint_limits(joint_name: str) -> Optional[Tuple[float, float]]
            def get_all_joint_names() -> List[str]
            def is_trajectory_joint(joint_name: str) -> bool
            def is_forward_command_joint(joint_name: str) -> bool
      </signature>
    </interface>
  </interfaces>

  <constraints>
    <constraint id="C1">REUSE ControllerInterface: Do NOT create new publishers or action clients. Use existing command_joint_group() method which handles trajectory vs forward command routing automatically.</constraint>
    <constraint id="C2">CONFIG SEPARATION: kinematic_chains.yaml contains ONLY group definitions (joint lists, descriptions, default velocities). Joint limits come from ControllerInterface (which loads from manipulator_params.yaml).</constraint>
    <constraint id="C3">FOLLOW MoveJointServer PATTERN: Use same structure - _load_config(), goal_callback() for validation, cancel_callback(), execute_callback() with feedback loop, _calc_progress().</constraint>
    <constraint id="C4">CONTAINER MIMIC MODE: When mimic_mode=true, accept SINGLE value in target_positions. Calculate left=-val/2, right=+val/2. This is for software synchronization (hardware uses mechanical mimic).</constraint>
    <constraint id="C5">AGGREGATE PROGRESS: Average of individual joint progress. Individual = (traveled/total)*100. Report average in feedback.</constraint>
    <constraint id="C6">COORDINATED ARRIVAL: Track when each joint first reaches tolerance. All must complete within 1-second window. Log warning if coordination fails but still succeed if positions reached.</constraint>
    <constraint id="C7">MANDATORY TESTING: Developer MUST personally verify coordinated motion in Gazebo - watch all joints move simultaneously, not sequentially.</constraint>
  </constraints>

  <tests>
    <standards>
      Manual testing with Gazebo/RViz is primary validation. Verify joints move simultaneously (not sequentially). Test each named group. Verify container jaws open symmetrically. Automated tests can verify action interface, validation logic, and progress calculation.
    </standards>
    <locations>
      <location>ros2_ws/src/manipulator_control/test/</location>
      <location>ros2_ws/src/manipulator_control/scripts/</location>
    </locations>
    <ideas>
      <idea ac="AC1">ros2 action list | grep move_joint_group - verify action available</idea>
      <idea ac="AC2">Verify kinematic_chains.yaml loads without error on node startup</idea>
      <idea ac="AC3">Send goal with wrong array length, verify REJECT response</idea>
      <idea ac="AC3">Send goal with out-of-limits position, verify REJECT response</idea>
      <idea ac="AC4">Send navigation group goal, verify both joints move</idea>
      <idea ac="AC5">Monitor feedback during motion, verify progress increases smoothly</idea>
      <idea ac="AC6">Verify success when all joints reach tolerance</idea>
      <idea ac="AC7">ros2 topic hz /move_joint_group/_action/feedback - verify ~10 Hz</idea>
      <idea ac="AC8">Test each named group: navigation, gripper, picker, container</idea>
      <idea ac="AC9">Send container goal with single value 0.15, verify left=-0.075, right=+0.075</idea>
      <idea ac="AC10">Monitor completion times, verify all within 1 second</idea>
    </ideas>
  </tests>

  <implementationNotes>
    <note id="N1">
      <title>Joint Soft Limits Reference</title>
      <content>
        From manipulator_params.yaml safety_controller sections:
        - base_main_frame_joint: [0.1, 3.9]
        - main_frame_selector_frame_joint: [0.05, 1.45]
        - selector_frame_gripper_joint: [-0.39, 0.39]
        - selector_frame_picker_frame_joint: [0.005, 0.29]
        - picker_frame_picker_rail_joint: [-0.29, 0.29]
        - picker_rail_picker_base_joint: [0.005, 0.24]
        - picker_base_picker_jaw_joint: [0.005, 0.19]
        - selector_left_container_jaw_joint: [-0.19, 0.19]
        - selector_right_container_jaw_joint: [-0.19, 0.19]

        ControllerInterface.get_joint_limits() returns these - use it for validation.
      </content>
    </note>
    <note id="N2">
      <title>Container Mimic Implementation</title>
      <content>
        When detecting container group (mimic_mode=true in config):

        1. Accept single value in target_positions (opening width)
        2. Calculate symmetric positions:
           left_target = -opening / 2
           right_target = +opening / 2
        3. Validate both calculated values against joint limits
        4. Command both joints with ControllerInterface.command_joint()

        Example: opening=0.15 -> left=-0.075, right=+0.075
      </content>
    </note>
    <note id="N3">
      <title>Aggregate Progress Calculation</title>
      <content>
        def calc_aggregate_progress(starts, currents, targets):
            total = 0.0
            for s, c, t in zip(starts, currents, targets):
                dist = abs(t - s)
                if dist &lt; 0.001:
                    progress = 100.0
                else:
                    progress = min(100.0, abs(c - s) / dist * 100.0)
                total += progress
            return total / len(starts)
      </content>
    </note>
    <note id="N4">
      <title>Launch File Addition Pattern</title>
      <content>
        # Add after move_joint_server_node in manipulator_simulation.launch.py:

        move_joint_group_server_node = TimerAction(
            period=3.0,
            actions=[
                Node(
                    package='manipulator_control',
                    executable='move_joint_group_server',
                    name='move_joint_group_server',
                    output='screen'
                )
            ]
        )

        # Add to LaunchDescription return list
      </content>
    </note>
    <note id="N5">
      <title>CMakeLists.txt Addition</title>
      <content>
        # Add install rule for MoveJointGroup server:
        install(
          PROGRAMS
            src/move_joint_group_server.py
          DESTINATION lib/${PROJECT_NAME}
          RENAME move_joint_group_server
        )

        # kinematic_chains.yaml will be installed with existing config directory install
      </content>
    </note>
  </implementationNotes>
</story-context>
